\chapter{C++}


C++ is a general-purpose programming language. It has imperative, object-oriented and generic programming features, while also providing facilities for low-level memory manipulation. It was designed with a bias toward system programming and embedded, resource-constrained and large systems, with performance, efficiency and flexibility of use as its design highlights. C++ has also been found useful in many other contexts, with key strengths being software infrastructure and resource-constrained applications, including desktop applications, servers (e.g. e-commerce, web search or SQL servers), and performance-critical applications (e.g. telephone switches or space probes). C++ is a compiled language, with implementations of it available on many platforms and provided by various organizations, including the Free Software Foundation (FSF's GCC), LLVM, Microsoft, Intel and IBM.

View online \href{http://magizbox.com/training/cpp/site/}{http://magizbox.com/training/cpp/site/}

\section{Get Started}

What do I need to start with CLion?
In general to develop in C/C++ with CLion you need:

CMake, 2.8.11+ (Check JetBrains guide for updates)
GCC/G++/Clang (Linux) or
MinGW 3. or MinGW — w64 3.-4. or Cygwin 1.7.32 (minimum required) up to 2.0. (Windows)
Downloading and Installing CMake
Downloading and installing CMake is pretty simple, just go to the website, download and install by following the recommended guide there or the on Desktop Wizard.

Download and install file cmake-3.9.0-win64-x65.msi
> cmake
Usage

  cmake [options] <path-to-source>
  cmake [options] <path-to-existing-build>

Specify a source directory to (re-)generate a build system for it in the
current working directory.  Specify an existing build directory to
re-generate its build system.

Run 'cmake --help' for more information.
Downloading and Getting Cygwin
Cygwin is a large collection of GNU and Open Source tools which provide functionality similar to a Linux distribution on Windows

Download file setup-x86_64.exe from the website https://cygwin.com/install.html

Install setup-x86_64.exe file



This is the root directory where Cygwin will be located, usually the recommended C:\ works



Choose where to install LOCAL DOWNLOAD PACKAGES: This is not the same as root directory, but rather where packages (ie. extra C libraries and tools) you download using Cygwin will be located



Follow the recommended instructions until you get to packages screen:



Once you get to the packages screen, this is where you customize what libraries or tools you will install. From here on I followed the above guide but here’s the gist:

From this window, choose the Cygwin applications to install. For our purposes, you will select certain GNU C/C++ packages.

Click the + sign next to the Devel category to expand it.

You will see a long list of possible packages that can be downloaded. Scroll the list to see more packages.

Pick each of the following packages by clicking its corresponding “Skip” marker.

gcc-core: C compiler subpackage
gcc-g++: C++ subpackage
libgcc1: C runtime library
gdb: The GNU Debugger
make: The GNU version of the ‘make’ utility
libmpfr4 : A library for multiple-precision floating-point arithmetic with exact rounding
Download and install CLion
Download file CLion-2017.2.exe from website https://www.jetbrains.com/clion/download/#section=windows



Config environment File > Settings... > Build, Execution, Deployment

Choose Cygwin home: C:\cygwin64
Choose CMake executable: Bundled CMake 3.8.2
Run your first C++ program with CLion

\section{Basic Syntax}

C/C++
Hello World
#include <iostream>
using namespace std;

int main() {
    cout << "hello world";
}
Convention
Naming
variable_name_like_this
class_data_memeber_name_like_this_
kConstantNamesLikeThis
ClassNameLikeThis
filenamelikethis_myusefulclass_test.cc
Comment
Class Comment
// Iterates over the contents of a GargantuanTable.
// Example:
//    GargantuanTableIterator* iter = table->NewIterator();
//    for (iter->Seek("foo"); !iter->done(); iter->Next()) {
//      process(iter->key(), iter->value());
//    }
//    delete iter;
class GargantuanTableIterator {
  ...
};
Todo Comment
// TODO(kl@gmail.com): Use a "*" here for concatenation operator.
// TODO(Zeke) change this to use relations.

\section{Cấu trúc dữ liệu}

Data Structure
Number
C++ offer the programmer a rich assortment of built-in as well as user defined data types. Following table lists down seven basic C++ data types:

Boolean - bool
Character - char
Integer - int
Floating point - float
Double floating point - double
Valueless - void
Wide character - wchar_t
Several of the basic types can be modified using one or more of these type modifiers: signed, unsigned, short, long

Following is the example, which will produce correct size of various data types on your computer.

#include <iostream>
using namespace std;

int main() {
   cout << "Size of char : " << sizeof(char) << endl;
   cout << "Size of int : " << sizeof(int) << endl;
   cout << "Size of short int : " << sizeof(short int) << endl;
   cout << "Size of long int : " << sizeof(long int) << endl;
   cout << "Size of float : " << sizeof(float) << endl;
   cout << "Size of double : " << sizeof(double) << endl;
   cout << "Size of wchar_t : " << sizeof(wchar_t) << endl;
   return 0;
}
String
String Basic

#include <iostream>
#include <string>
using namespace std ;

// assign a string
string s1 = "www.java2s.com\n";
cout << s1;

// input a string
string s2;
cin >> s2;

// concatenate two strings
string s_c = s1 + s2;

// compare strings
s1 == s2;
Collection
Pointer
A pointer is a variable whose value is the address of another variable. Like any variable or constant, you must declare a pointer before you can work with it.

The general form of a pointer variable declaration is:

type *variable_name;
// example
int    *ip;    // pointer to an integer
double *dp;    // pointer to a double
float  *fp;    // pointer to a float
char   *ch;    // pointer to character
Pointer Lab



#include <iostream>
using namespace std;

/*
 * Look at these lines
 */
int* a;
a = new int[3];
a[0] = 10;
a[1] = 2;
cout << "Address of pointer a: &a = " << &a << endl;
cout << "Value   of pointer a:  a = " << a << endl << endl;
cout << "Address of a[0]: &a[0] = " << &a[0] << endl;
cout << "Value   of a[0]: a[0]  = " << a[0]  << endl;
cout << "Value   of a[0]: *a    = " << *a    << endl << endl;
cout << "Address of a[1]: &a[1] = " << &a[1] << endl;
cout << "Value   of a[1]: a[1]  = " << a[1]  << endl;
cout << "Value   of a[1]: *(a+1)= " << *(a+1)<< endl << endl;
cout << "Address of a[2]: &a[2] = " << &a[2] << endl;
cout << "Value   of a[2]: a[2]  = " << a[2]  << endl;
cout << "Value   of a[2]: *(a+2)= " << *(a+2)<< endl << endl;
Result:

Address of pointer a: &a = 008FF770
Value   of pointer a:  a = 00C66ED0

Address of a[0]: &a[0] = 00C66ED0
Value   of a[0]: a[0]  = 10
Value   of a[0]: *a    = 10

Address of a[1]: &a[1] = 00C66ED4
Value   of a[1]: a[1]  = 2
Value   of a[1]: *(a+1)= 2

Address of a[2]: &a[2] = 00C66ED8
Value   of a[2]: a[2]  = -842150451
Value   of a[2]: *(a+2)= -842150451
Stack, Queue, Linked List, Array, Deque, List, Map, Set

Datetime
The C++ standard library does not provide a proper date type. C++ inherits the structs and functions for date and time manipulation from C. To access date and time related functions and structures, you would need to include header file in your C++ program.

There are four time-related types: clock_t, time_t, size_t, and tm. The types clock_t, size_t and time_t are capable of representing the system time and date as some sort of integer.

The structure type tm holds the date and time in the form of a C structure having the following elements:

struct tm {
   int tm_sec;   // seconds of minutes from 0 to 61
   int tm_min;   // minutes of hour from 0 to 59
   int tm_hour;  // hours of day from 0 to 24
   int tm_mday;  // day of month from 1 to 31
   int tm_mon;   // month of year from 0 to 11
   int tm_year;  // year since 1900
   int tm_wday;  // days since sunday
   int tm_yday;  // days since January 1st
   int tm_isdst; // hours of daylight savings time
}
Current date and time

Consider you want to retrieve the current system date and time, either as a local time or as a Coordinated Universal Time (UTC). Following is the example to achieve the same:

#include <iostream>
#include <ctime>

using namespace std;

int main( ) {
   // current date/time based on current system
   time_t now = time(0);

   // convert now to string form
   char* dt = ctime(&now);

   cout << "The local date and time is: " << dt << endl;

   // convert now to tm struct for UTC
   tm *gmtm = gmtime(&now);
   dt = asctime(gmtm);
   cout << "The UTC date and time is:"<< dt << endl;
}
When the above code is compiled and executed, it produces the following result:

The local date and time is: Sat Jan  8 20:07:41 2011

The UTC date and time is:Sun Jan  9 03:07:41 2011

\section{Lập trình hướng đối tượng}

Object Oriented Programming
Classes and Objects
#include <iostream>
using namespace std;

class Pacman {

    private:
      int x;
      int y;
    public:
    Pacman(int x, int y);
    void show();
};

Pacman::Pacman(int x, int y){
    this->x = x;
    this->y = y;
}

void Pacman::show(){
    std::cout << "(" << this->x << ", " << this->y << ")";
}

int main() {
    // your code goes here
    Pacman p = Pacman(2, 3);
    p.show();
    return 0;
}
Template
Function Template

#include <iostream>
#include <string>

using namespace std;

template <typename T>

T Max(T a, T b)
{
    return a < b ? b : a;
}

int main()
{

    int i = 39;
    int j = 20;
    cout << Max(i, j) << endl;

    double f1 = 13.5;
    double f2 = 20.7;
    cout << Max(f1, f2) << endl;

    string s1 = "Hello";
    string s2 = "World";
    cout << Max(s1, s2) << endl;

    double n1 = 20.3;
    float n2 = 20.4;
    // it will show an error
    // Error: no instance of function template "Max" matches the argument list
    //        arguments types are: (double, float)
    cout << Max(n1, n2) << endl;
    return 0;
}

\section{Cơ sở dữ liệu}


Database
Sqlite with Visual Studio 2013
Step 1: Create new project 1.1 Create a new C++ Win32 Console application.

Step 2: Download Sqlite DLL

2.1. Download the native SQLite DLL from: http://sqlite.org/sqlite-dll-win32-x86-3070400.zip 2.2. Unzip the DLL and DEF files and place the contents in your project’s source folder (an easy way to find this is to right click on the tab and click the “Open Containing Folder” menu item.

Step 3: Build LIB file

3.1. Open a “Developer Command Prompt” and navigate to your source folder. (If you can't find this tool, follow this post in stackoverflow Where is Developer Command Prompt for VS2013? to create it) 3.2. Create an import library using the following command line: LIB /DEF:sqlite3.def

Step 4: Add Dependencies

4.1. Add the library (i.e. sqlite3.lib) to your Project Properties -> Configuration Properties -> Linker -> Input -> Additional Dependencies. 4.2. Download http://sqlite.org/sqlite-amalgamation-3070400.zip 4.3. Unzip the sqlite3.h header file and place into your source directory. 4.4. Include the the sqlite3.h header file in your source code. 4.5. You will need to include the sqlite3.dll in the same directory as your program (or in a System Folder).

Step 5: Run test code

#include "stdafx.h"
#include <ios>
#include <iostream>
#include "sqlite3.h"

using namespace std;

int _tmain(int argc, _TCHAR* argv[])
{
   int rc;
   char *error;

   // Open Database
   cout << "Opening MyDb.db ..." << endl;
   sqlite3 *db;
   rc = sqlite3_open("MyDb.db", &db);
   if (rc)
   {
      cerr << "Error opening SQLite3 database: " << sqlite3_errmsg(db) << endl << endl;
      sqlite3_close(db);
      return 1;
   }
   else
   {
      cout << "Opened MyDb.db." << endl << endl;
   }

   // Execute SQL
   cout << "Creating MyTable ..." << endl;
   const char *sqlCreateTable = "CREATE TABLE MyTable (id INTEGER PRIMARY KEY, value STRING);";
   rc = sqlite3_exec(db, sqlCreateTable, NULL, NULL, &error);
   if (rc)
   {
      cerr << "Error executing SQLite3 statement: " << sqlite3_errmsg(db) << endl << endl;
      sqlite3_free(error);
   }
   else
   {
      cout << "Created MyTable." << endl << endl;
   }

   // Execute SQL
   cout << "Inserting a value into MyTable ..." << endl;
   const char *sqlInsert = "INSERT INTO MyTable VALUES(NULL, 'A Value');";
   rc = sqlite3_exec(db, sqlInsert, NULL, NULL, &error);
   if (rc)
   {
      cerr << "Error executing SQLite3 statement: " << sqlite3_errmsg(db) << endl << endl;
      sqlite3_free(error);
   }
   else
   {
      cout << "Inserted a value into MyTable." << endl << endl;
   }

   // Display MyTable
   cout << "Retrieving values in MyTable ..." << endl;
   const char *sqlSelect = "SELECT * FROM MyTable;";
   char **results = NULL;
   int rows, columns;
   sqlite3_get_table(db, sqlSelect, &results, &rows, &columns, &error);
   if (rc)
   {
      cerr << "Error executing SQLite3 query: " << sqlite3_errmsg(db) << endl << endl;
      sqlite3_free(error);
   }
   else
   {
      // Display Table
      for (int rowCtr = 0; rowCtr <= rows; ++rowCtr)
      {
         for (int colCtr = 0; colCtr < columns; ++colCtr)
         {
            // Determine Cell Position
            int cellPosition = (rowCtr * columns) + colCtr;

            // Display Cell Value
            cout.width(12);
            cout.setf(ios::left);
            cout << results[cellPosition] << " ";
         }

         // End Line
         cout << endl;

         // Display Separator For Header
         if (0 == rowCtr)
         {
            for (int colCtr = 0; colCtr < columns; ++colCtr)
            {
               cout.width(12);
               cout.setf(ios::left);
               cout << "~~~~~~~~~~~~ ";
            }
            cout << endl;
         }
      }
   }
   sqlite3_free_table(results);

   // Close Database
   cout << "Closing MyDb.db ..." << endl;
   sqlite3_close(db);
   cout << "Closed MyDb.db" << endl << endl;

   // Wait For User To Close Program
   cout << "Please press any key to exit the program ..." << endl;
   cin.get();

   return 0;
}

\section{Testing}

Create Unit Test in Visual Studio 2013
Step 1. Create TDDLab Solution
1.1 Open Visual Studio 2013

1.2 File ->  New Project... ->

Click Visual C++ -> Win32

Choose Win32 Console Application

Fill to Name input text: TDDLab

Click OK -> Next

1.3 In project settings, remove options:

Precompiled Header
Securirty Develoment Lifecyde(SQL) check
1.4 Click Finish

Step 2. Create Counter Class
2.1 Right-click TDDLab -> Add -> Class...

2.2 Choose Visual C++ -> C++ Class -> Add

2.3 Fill in Class name box Counter -> Finish

2.4 In Counter.h file, add this below function

int add(int a, int b);
2.5 In Counter.cpp, add this below function

int Counter::add(int a, int b) {
  return a+b;
}
Your Counter class should look like this



Step 3. Create TDDLabTest Project
3.1 Right-click Solution 'TDDLab' -> Add -> New Project...

3.2 Choose Visual C++ -> Test

3.3 Choose Native Unit Test Project

3.4 Fill to Name input text: TDDLabTest

Step 4. Write unit test
4.1 In unittest1.cpp, add header of Counter class

#include "../TDDLab/Counter.h"
4.2 In TEST_METHOD function

{
  Counter counter;
  Assert::AreEqual(2, counter.add(1, 1));
}
4.3 Click TEST in menu bar -> Run -> `All Test (Ctrl + R, A)

Step 5. Fix error LNK 2019: unresolved external symbol
5.1 Change Configuration Type of TDDLab project

Right click  TDDLab project -> Properties
General -> Configuration Type -> Static library (.lib) -> OK
5.2 Add Reference to TDDLabTest project

Right click TDDLabTest solution -> Properties -> Common Properties -> Add New Reference
Choose TDDLab -> OK -> OK
Step 6. Run Tests
Click TEST in menu bar -> Run -> `All Test (Ctrl + R, A)

Test should be passed.

\section{IDE & Debugging}

Visual Studio 2013
Install Extension

VsVim

googletest guide

Folder Structure with VS 2013

solution
│   README.md
│
|───project1
|   │   file011.txt
|   │   file012.txt
|   │
|───project2
|   │   file011.txt
|   │   file012.txt
|   │
Auto Format

Ctrl + K, Ctrl + D
Git in Visual Studio

https://git-scm.com/book/en/v2/Git-in-Other-Environments-Git-in-Visual-Studio

Online IDE
codechef ide

